(proclaim '(optimize (speed 3) (safety 1) (space 2) (debug 1)))
;; (proclaim '(optimize (speed HPS_COMPILER_SPEED) (safety HPS_COMPILER_SAFETY) (space HPS_COMPILER_SPACE) (debug HPS_COMPILER_DEBUG)))
;; ********************************************************************************************************
;; *************************** THE HPS TRANSFORM :   DEBUGGER I/O         *********************************
;; ********************************************************************************************************


;; ********************************************************************************************
;; ********************************************************************************************
;; THIS MODULE IS PART OF AN IMPLEMENTATION OF AN ONLINE HPS TRANSFORM.  THE HPS TRANSFORM WAS 
;; DESCRIBED IN THE PAPER ENTITLED: 
;; 			    THE HPS TRANSFORM AND ITS APPLICATIONS
;;                          www3.webng.com/nelsonmanohar/research/
;;
;; 	          THIS CODE WAS WRITTEN AND ITS COPYRIGHTED (2007) BY 
;; 			    DR. NELSON R. MANOHAR ALERS
;; 			      nelsonmanohar@yahoo.com
;; 			           AUGUST 2007
;;
;; THIS CODE IS NOT IN THE PUBLIC DOMAIN. THIS CODE IS NOT INTENDED FOR DISTRIBUTION. PLEASE DO
;; NOT MODIFY THIS CODE. PLEASE INFORM THE AUTHOR OF ANY UNINTENDED OR UNAUTHORIZED DISTRIBUTION 
;; AND/OR ACCESS TO THIS CODE.
;; ********************************************************************************************


;; ********************************************************************************************************
;; these variables allow fine-grained control of the output, allowing to dump the internal state of the HPS
;; transform at specific iterations or even multiple iteration ranges, for example, the intervals given below
;; dump the internal state at around critical transient state points i=0, 30, 60, 90, 120, 150, 180, 220
;; ********************************************************************************************************
(setf *HPS_OUTPUT_MINOR_TICK* 	1000)					; output very general information  every so (minor) ticks 
(setf *HPS_OUTPUT_MAJOR_TICK* 	(* 5 *HPS_OUTPUT_MINOR_TICK*)) 		; output very detailed information every so (major) ticks
(setf *HPS_OUTPUT_ENABLER*      nil)					; enables output to the terminal
(setf *HPSdebug*		nil)					; enables debug output 
(setf *HPS_VALID_RANGES* 	'( 	(0 	5) 	  
				  	(29 	35) 	  
					(59 	65) 	  
					(89 	95) 	 
					(119 	125) 
					(149 	155)       
					(179 	185)	  
					(219 	225)))
(setf *HPS_PRINTDUMPSIZE* 	2)					; the number of elements in an array to print, first ones
;; ********************************************************************************************************


;; ********************************************************************************************************
;; these global values are used only within this module, and are used to control the density of the output being generated by the HPS transform
;; ********************************************************************************************************
(defun HPS_print_init (&key 	(outputenabler 	t)   
				(hpsdebug 	nil) 
				(arraydumpsize 	2)   
				(minortick 	100) 
				(majortick 	500))
  	(setf *HPSdebug*		hpsdebug)			; enables debug output 
	(setf *HPS_OUTPUT_ENABLER*      outputenabler)			; enables output to the terminal
	(setf *HPS_PRINTDUMPSIZE* 	arraydumpsize)			; the number of elements in an array to print, first ones
	(setf *HPS_OUTPUT_MINOR_TICK* 	minortick)			; output very general information  every so (minor) ticks 
	(setf *HPS_OUTPUT_MAJOR_TICK* 	majortick)) 			; output very detailed information every so (major) ticks
;; ********************************************************************************************************


;; ********************************************************************************************************
;; this generic function determines whether a number is within a particular range, the numbers representing iteration values.
;; ********************************************************************************************************
(defun HPS_valid_iteration (iter &key (from 0) (to 0))
	(if (AND (>= iter from) (<= iter to)) t nil))
;; ********************************************************************************************************


;; ********************************************************************************************************
;; this function determines if a given iteration has been enabled for output or not
;; ********************************************************************************************************
(defun HPS_PRINT_CHECK ()
	(dolist (arange *HPS_VALID_RANGES* 'HPSPRINTCHECK)
		(if (HPS_valid_iteration *HPS_iteration* :from (first arange) :to (second arange))
			(return-from HPS_PRINT_CHECK arange)
			nil))
	(return-from HPS_PRINT_CHECK nil))
;; ********************************************************************************************************


;; ********************************************************************************************************
;; this is the the actual debugger formatter function this basic debugger prints messages to the console.
;; ********************************************************************************************************
(defun HPS_VAR_INTERNAL ( text var &key (level 1) (forced nil))
  	(when (OR forced (HPS_PRINT_CHECK) (equal (mod *HPS_iteration* *HPS_OUTPUT_MAJOR_TICK* ) 0))
	  	(if (listp var)
		  	(if (> (length var) *HPS_PRINTDUMPSIZE*)
	  			(setf *HPS_temp_print_var* (subseq var 0 *HPS_PRINTDUMPSIZE*))
	  			(setf *HPS_temp_print_var* var))
	  		(setf *HPS_temp_print_var* var))
  		(cond 
			((equal level 1) (format t "~%L1: [~S] --> ~80:S" text *HPS_temp_print_var* ))
			((equal level 2) (format t "~%L2:     [~S] --> ~80:S" text *HPS_temp_print_var* ))
			((equal level 3) (format t "~%L3:         [~S] --> ~80:S" text *HPS_temp_print_var* ))
			((equal level 4) (format t "~%L4:             [~S] --> ~80:S" text *HPS_temp_print_var* ))
			((equal level 5) (format t "~%L5:                 [~S] --> ~80:S" text *HPS_temp_print_var* ))
			(t (format t "%" nil))))
  	(unless (OR forced (HPS_PRINT_CHECK) (equal (mod *HPS_iteration* *HPS_OUTPUT_MAJOR_TICK* ) 0))
	  nil))
;; ********************************************************************************************************


;; ********************************************************************************************************
;; this is the the external debugger function definition, this function prevents unnecessary low-level
;; debugger checks at each iteration.
;; ********************************************************************************************************
(defun HPS_VAR ( text var &key (level 1) (forced nil))
 	(if (AND *HPS_OUTPUT_ENABLER* *HPS_outputmode*) (HPS_VAR_INTERNAL text var :level level :forced forced) nil))
;; ********************************************************************************************************









